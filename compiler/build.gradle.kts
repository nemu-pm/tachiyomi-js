import groovy.json.JsonSlurper

plugins {
    kotlin("multiplatform") version "2.1.0"
    kotlin("plugin.serialization") version "2.1.0"
}

// =============================================================================
// Extension Configuration via Manifest
// =============================================================================

// Check if building a specific extension
val extensionPath: String? = project.findProperty("extension")?.toString()
val isExtensionBuild = extensionPath != null

// Find the extension we're building
val extensionParts = extensionPath?.split("/") ?: listOf("all", "mangadex")
val extensionLang = extensionParts.getOrElse(0) { "all" }
val extensionName = extensionParts.getOrElse(1) { "mangadex" }

// Load extension metadata from manifest (generated by dev/scan-extensions.ts)
val manifestFile = rootProject.file("extensions-manifest.json")
data class ExtensionManifest(
    val lang: String,
    val name: String,
    val extName: String,
    val extClassName: String,
    val extVersionCode: Int,
    val isNsfw: Boolean,
    val themePkg: String?,
    val libDeps: List<String>
)

val extensionMetadata: ExtensionManifest? = if (manifestFile.exists()) {
    @Suppress("UNCHECKED_CAST")
    val json = JsonSlurper().parseText(manifestFile.readText()) as List<Map<String, Any?>>
    json.find { it["lang"] == extensionLang && it["name"] == extensionName }?.let { m ->
        ExtensionManifest(
            lang = m["lang"] as String,
            name = m["name"] as String,
            extName = m["extName"] as String,
            extClassName = m["extClassName"] as String,
            extVersionCode = (m["extVersionCode"] as Number).toInt(),
            isNsfw = m["isNsfw"] as Boolean,
            themePkg = m["themePkg"] as String?,
            libDeps = (m["libDeps"] as? List<*>)?.filterIsInstance<String>() ?: emptyList()
        )
    }
} else {
    null
}

// Extension properties (from manifest or defaults for non-manifest builds)
val extClassName = extensionMetadata?.extClassName ?: extensionName.replaceFirstChar { it.uppercase() }
val extVersionCode = extensionMetadata?.extVersionCode ?: 1
val extName = extensionMetadata?.extName ?: extensionName
val isNsfw = extensionMetadata?.isNsfw ?: false
val themePkg = extensionMetadata?.themePkg
val libDeps = extensionMetadata?.libDeps ?: emptyList()

// =============================================================================
// Configurable Paths (for tachiyomi-js-sources separation)
// =============================================================================

// Root of keiyoushi extensions-source repo (contains src/, lib/, lib-multisrc/, core/)
val extensionsRoot = project.findProperty("extensionsRoot")?.toString()
    ?: rootProject.file("../../vendor/keiyoushi/extensions-source").absolutePath

// Output directory for built extensions
val extensionsOutputDir = project.findProperty("outputDir")?.toString()
    ?: rootProject.file("../../dev/tachiyomi-extensions").absolutePath

// Authors script path (optional - for tachiyomi-js-sources)
val authorsScriptPath: String? = project.findProperty("authorsScript")?.toString()

// Computed paths from extensionsRoot
val extensionSourcePath = File(extensionsRoot, "src/$extensionLang/$extensionName/src")
val multisrcPath = themePkg?.let { File(extensionsRoot, "lib-multisrc/$it/src") }
val libPaths = libDeps.map { libName -> File(extensionsRoot, "lib/$libName/src/main/java") }

// Note: keiyoushi's core/ (keiyoushi/utils) uses JVM-only APIs (decodeFromStream, etc.)
// Our shim provides JS-compatible implementations of the same API

if (isExtensionBuild && !extensionSourcePath.exists()) {
    logger.warn("Extension source not found at: $extensionSourcePath")
}

group = "tachiyomi.js"
version = "1.0.0"

// Generated/preprocessed directories
val generatedSrcDir = layout.buildDirectory.dir("generated/src/jsMain/kotlin")
val preprocessedSrcDir = layout.buildDirectory.dir("preprocessed/src")

// =============================================================================
// Static Configuration (serializable for config cache)
// =============================================================================

// Imports to add to extension source files
val jsImports = listOf(
    "import java.lang.System",
    "import java.lang.Integer", 
    "import java.lang.Class",
    "import java.lang.Character",
    "import java.nio.charset.Charsets",
    "import java.nio.charset.toString",
    "import java.nio.charset.toByteArray",
    "import java.util.Arrays",
    "import tachiyomi.shim.compat.*"
)

// Shimmed files to skip
val shimmedFiles = setOf(
    "eu/kanade/tachiyomi/lib/i18n/Intl.kt"
)

// Main.kt template
val mainKtTemplate = """
@file:OptIn(ExperimentalJsExport::class)

package tachiyomi.generated

import {{PACKAGE_NAME}}.{{EXT_CLASS_NAME}}
import eu.kanade.tachiyomi.source.Source
import eu.kanade.tachiyomi.source.SourceFactory
import eu.kanade.tachiyomi.source.CatalogueSource
import eu.kanade.tachiyomi.source.online.HttpSource
import eu.kanade.tachiyomi.source.model.SManga
import eu.kanade.tachiyomi.source.model.SChapter
import eu.kanade.tachiyomi.source.model.Filter
import eu.kanade.tachiyomi.source.model.FilterList
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import kotlinx.serialization.json.intOrNull
import kotlinx.serialization.json.booleanOrNull
import kotlinx.serialization.json.contentOrNull
import kotlinx.serialization.json.encodeToJsonElement
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.buildJsonArray
import kotlinx.serialization.json.put
import kotlinx.serialization.json.putJsonArray
import kotlinx.serialization.json.putJsonObject
import kotlinx.serialization.json.add
import kotlinx.serialization.encodeToString
import kotlinx.serialization.Serializable
import kotlin.js.JsExport

private val json = Json { 
    prettyPrint = false
    ignoreUnknownKeys = true
}

// Log buffer for capturing println output
private val logBuffer = mutableListOf<String>()

private fun log(msg: String) {
    logBuffer.add(msg)
    println(msg)
}

@JsExport
fun getLogs(): String {
    val logs = logBuffer.toList()
    logBuffer.clear()
    return json.encodeToString(logs)
}

// Result wrapper - all exports return this format
private inline fun <reified T> success(data: T): String {
    return buildJsonObject {
        put("ok", true)
        put("data", json.encodeToJsonElement(data))
    }.toString()
}

private fun successJson(data: JsonElement): String {
    return buildJsonObject {
        put("ok", true)
        put("data", data)
    }.toString()
}

private fun error(e: Throwable): String {
    val stackTrace = e.stackTraceToString()
    return buildJsonObject {
        put("ok", false)
        putJsonObject("error") {
            put("type", e::class.simpleName ?: "Unknown")
            put("message", e.message ?: "No message")
            put("stack", stackTrace)
            putJsonArray("logs") { logBuffer.forEach { add(it) } }
        }
    }.toString().also { logBuffer.clear() }
}

private val instance = {{EXT_CLASS_NAME}}()
private val sources: List<Source> = when (instance) {
    is SourceFactory -> instance.createSources()
    is Source -> listOf(instance)
    else -> emptyList()
}

// Source lookup by ID (String representation of Long)
private val sourcesById: Map<String, Source> = sources.associateBy { it.id.toString() }

// Cached filters per source (for state management)
private val filterCache = mutableMapOf<String, FilterList>()

// DTO classes for JSON serialization
@Serializable
data class MangaDto(
    val url: String,
    val title: String,
    val artist: String?,
    val author: String?,
    val description: String?,
    val genre: List<String>,
    val status: Int,
    val thumbnailUrl: String?,
    val initialized: Boolean
)

@Serializable
data class ChapterDto(
    val url: String,
    val name: String,
    val dateUpload: Long,
    val chapterNumber: Float,
    val scanlator: String?
)

@Serializable
data class PageDto(
    val index: Int,
    val url: String,
    val imageUrl: String?
)

@Serializable
data class MangasPageDto(
    val mangas: List<MangaDto>,
    val hasNextPage: Boolean
)

private fun SManga.toDto() = MangaDto(
    url = url,
    title = title,
    artist = artist,
    author = author,
    description = description,
    genre = genre?.split(", ")?.filter { it.isNotBlank() } ?: emptyList(),
    status = status,
    thumbnailUrl = thumbnail_url,
    initialized = initialized
)

private fun SChapter.toDto() = ChapterDto(
    url = url,
    name = name,
    dateUpload = date_upload,
    chapterNumber = chapter_number,
    scanlator = scanlator
)

private fun eu.kanade.tachiyomi.source.model.Page.toDto() = PageDto(
    index = index,
    url = url,
    imageUrl = imageUrl
)

// ============================================================================
// Manifest: Returns all sources metadata (call once on load)
// ============================================================================

@JsExport
fun getManifest(): String = try {
    val sourcesJson = buildJsonArray {
        for (src in sources) {
            add(buildJsonObject {
                put("id", src.id.toString())
                put("name", src.name)
                put("lang", src.lang)
                if (src is HttpSource) {
                    put("baseUrl", src.baseUrl)
                }
                if (src is CatalogueSource) {
                    put("supportsLatest", src.supportsLatest)
                }
            })
        }
    }
    successJson(sourcesJson)
} catch (e: Throwable) { error(e) }

// ============================================================================
// Filter Schema: Serialize filters for UI rendering
// ============================================================================

private fun serializeFilter(filter: Filter<*>): JsonObject = buildJsonObject {
    put("name", filter.name)
    when (filter) {
        is Filter.Header -> put("type", "header")
        is Filter.Separator -> put("type", "separator")
        is Filter.CheckBox -> {
            put("type", "checkbox")
            put("state", filter.state)
        }
        is Filter.TriState -> {
            put("type", "tristate")
            put("state", filter.state)
        }
        is Filter.Text -> {
            put("type", "text")
            put("state", filter.state)
        }
        is Filter.Select<*> -> {
            put("type", "select")
            put("state", filter.state)
            putJsonArray("values") {
                filter.values.forEach { add(it.toString()) }
            }
        }
        is Filter.Sort -> {
            put("type", "sort")
            putJsonArray("values") {
                filter.values.forEach { add(it) }
            }
            if (filter.state != null) {
                putJsonObject("state") {
                    put("index", filter.state!!.index)
                    put("ascending", filter.state!!.ascending)
                }
            }
        }
        is Filter.Group<*> -> {
            put("type", "group")
            putJsonArray("filters") {
                @Suppress("UNCHECKED_CAST")
                (filter.state as? List<Filter<*>>)?.forEach { 
                    add(serializeFilter(it))
                }
            }
        }
    }
}

@JsExport
fun getFilterList(sourceId: String): String = try {
    val src = sourcesById[sourceId] as? CatalogueSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    val filters = src.getFilterList()
    filterCache[sourceId] = filters
    val filtersJson = buildJsonArray {
        filters.forEach { add(serializeFilter(it)) }
    }
    successJson(filtersJson)
} catch (e: Throwable) { error(e) }

/**
 * Reset filters to source default state.
 * Call this before starting a new search to clear previous filter state.
 */
@JsExport
fun resetFilters(sourceId: String): String = try {
    val src = sourcesById[sourceId] as? CatalogueSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    filterCache[sourceId] = src.getFilterList()
    successJson(buildJsonObject { put("ok", true) })
} catch (e: Throwable) { error(e) }

/**
 * Apply filter state from UI.
 * @param sourceId Source identifier
 * @param filterStateJson JSON array of filter state updates:
 *   [{ "index": 0, "state": true }, { "index": 2, "state": 1 }, ...]
 *   For Group filters: { "index": 3, "filters": [{ "index": 0, "state": true }] }
 *   For Sort filters: { "index": 5, "state": { "index": 1, "ascending": false } }
 */
@JsExport
fun applyFilterState(sourceId: String, filterStateJson: String): String = try {
    val filters = filterCache[sourceId]
        ?: throw Exception("Filters not loaded for source: ${"$"}sourceId. Call getFilterList first.")
    val stateUpdates = Json.parseToJsonElement(filterStateJson).jsonArray
    
    for (update in stateUpdates) {
        val obj = update.jsonObject
        val index = obj["index"]?.jsonPrimitive?.intOrNull ?: continue
        applyStateToFilter(filters.getOrNull(index) ?: continue, obj)
    }
    
    successJson(buildJsonObject { put("ok", true) })
} catch (e: Throwable) { error(e) }

private fun applyStateToFilter(filter: Filter<*>, state: JsonObject) {
    when (filter) {
        is Filter.CheckBox -> {
            state["state"]?.jsonPrimitive?.booleanOrNull?.let { filter.state = it }
        }
        is Filter.TriState -> {
            state["state"]?.jsonPrimitive?.intOrNull?.let { filter.state = it }
        }
        is Filter.Text -> {
            state["state"]?.jsonPrimitive?.contentOrNull?.let { filter.state = it }
        }
        is Filter.Select<*> -> {
            state["state"]?.jsonPrimitive?.intOrNull?.let { filter.state = it }
        }
        is Filter.Sort -> {
            state["state"]?.jsonObject?.let { sortState ->
                val idx = sortState["index"]?.jsonPrimitive?.intOrNull ?: 0
                val asc = sortState["ascending"]?.jsonPrimitive?.booleanOrNull ?: false
                filter.state = Filter.Sort.Selection(idx, asc)
            }
        }
        is Filter.Group<*> -> {
            val groupFilters = state["filters"]?.jsonArray ?: return
            @Suppress("UNCHECKED_CAST")
            val childFilters = filter.state as? List<Filter<*>> ?: return
            for (childUpdate in groupFilters) {
                val childObj = childUpdate.jsonObject
                val childIndex = childObj["index"]?.jsonPrimitive?.intOrNull ?: continue
                applyStateToFilter(childFilters.getOrNull(childIndex) ?: continue, childObj)
            }
        }
        else -> { /* Header, Separator - no state to apply */ }
    }
}

// ============================================================================
// Data Methods (use sourceId instead of index)
// ============================================================================

@JsExport
fun getPopularManga(sourceId: String, page: Int): String = try {
    val src = sourcesById[sourceId] as? CatalogueSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    val result = src.getPopularManga(page)
    success(MangasPageDto(
        mangas = result.mangas.map { it.toDto() },
        hasNextPage = result.hasNextPage
    ))
} catch (e: Throwable) { error(e) }

@JsExport
fun getLatestUpdates(sourceId: String, page: Int): String = try {
    val src = sourcesById[sourceId] as? CatalogueSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    val result = src.getLatestUpdates(page)
    success(MangasPageDto(
        mangas = result.mangas.map { it.toDto() },
        hasNextPage = result.hasNextPage
    ))
} catch (e: Throwable) { error(e) }

@JsExport
fun searchManga(sourceId: String, page: Int, query: String): String = try {
    val src = sourcesById[sourceId] as? CatalogueSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    val filters = filterCache[sourceId] ?: FilterList()
    val result = src.getSearchManga(page, query, filters)
    success(MangasPageDto(
        mangas = result.mangas.map { it.toDto() },
        hasNextPage = result.hasNextPage
    ))
} catch (e: Throwable) { error(e) }

@JsExport
fun getMangaDetails(sourceId: String, mangaUrl: String): String = try {
    val src = sourcesById[sourceId] as? CatalogueSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    val manga = SManga.create().apply { url = mangaUrl }
    val result = src.getMangaDetails(manga)
    // Copy URL from input manga - getMangaDetails doesn't always set it
    if (result.url.isEmpty()) result.url = mangaUrl
    success(result.toDto())
} catch (e: Throwable) { error(e) }

@JsExport
fun getChapterList(sourceId: String, mangaUrl: String): String = try {
    val src = sourcesById[sourceId] as? CatalogueSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    val manga = SManga.create().apply { url = mangaUrl }
    val result = src.getChapterList(manga)
    success(result.map { it.toDto() })
} catch (e: Throwable) { error(e) }

@JsExport
fun getPageList(sourceId: String, chapterUrl: String): String = try {
    val src = sourcesById[sourceId] as? HttpSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    val chapter = SChapter.create().apply { url = chapterUrl }
    val result = src.getPageList(chapter)
    success(result.map { it.toDto() })
} catch (e: Throwable) { error(e) }

/**
 * Fetch an image through the source's OkHttp client (with interceptors).
 * This is required for sources that use image descrambling/processing.
 * Returns base64-encoded image bytes.
 */
@JsExport
fun fetchImage(sourceId: String, pageUrl: String, pageImageUrl: String): String = try {
    val src = sourcesById[sourceId] as? HttpSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    val page = eu.kanade.tachiyomi.source.model.Page(0, pageUrl, pageImageUrl)
    val request = src.imageRequest(page)
    
    // Execute through client WITH interceptors (needed for image descrambling)
    val response = src.client.newCall(request).execute()
    val bytes = response.body.bytes()
    response.close()
    
    // Return base64-encoded image
    val base64 = java.util.Base64.getEncoder().encodeToString(bytes)
    success(base64)
} catch (e: Throwable) { error(e) }

/**
 * Get the source's default headers (includes Referer from headersBuilder).
 * Returns JSON object with header name-value pairs.
 */
@JsExport
fun getHeaders(sourceId: String): String = try {
    val src = sourcesById[sourceId] as? HttpSource
        ?: throw Exception("Source not found: ${"$"}sourceId")
    
    val headersMap = mutableMapOf<String, String>()
    for (name in src.headers.names()) {
        headersMap[name] = src.headers.get(name) ?: ""
    }
    success(headersMap)
} catch (e: Throwable) { error(e) }

// ============================================================================
// Preferences API
// ============================================================================

/**
 * Get settings schema for a source. 
 * Invokes setupPreferenceScreen to capture preference definitions.
 */
@JsExport
fun getSettingsSchema(sourceId: String): String = try {
    val src = sourcesById[sourceId]
        ?: throw Exception("Source not found: ${"$"}sourceId")
    
    // Clear any existing schema
    androidx.preference.PreferenceRegistry.clear()
    
    // If source is ConfigurableSource, call setupPreferenceScreen
    if (src is eu.kanade.tachiyomi.source.ConfigurableSource) {
        val context = android.content.Context()
        val screen = androidx.preference.PreferenceScreen(context)
        src.setupPreferenceScreen(screen)
    }
    
    // Return captured schema
    success(androidx.preference.PreferenceRegistry.getAllSchemasJson())
} catch (e: Throwable) { error(e) }

// ============================================================================
// Legacy index-based API (deprecated)
// ============================================================================

@JsExport
fun getSourceCount(): Int = sources.size

@JsExport
fun getSourceInfo(index: Int): String {
    val src = sources.getOrNull(index) ?: return success(emptyMap<String, String>())
    val httpSrc = src as? HttpSource
    return success(mapOf(
        "id" to src.id.toString(),
        "name" to src.name,
        "lang" to src.lang,
        "baseUrl" to (httpSrc?.baseUrl ?: "")
    ))
}
""".trimIndent()

// =============================================================================
// Kotlin Multiplatform Configuration
// =============================================================================

kotlin {
    js(IR) {
        if (isExtensionBuild) {
            moduleName = "$extensionLang-$extensionName"
        }
        
        browser {
            webpackTask {
                enabled = false  // We use bun bundler instead
            }
            testTask {
                enabled = false
            }
        }
        
        if (isExtensionBuild) {
            binaries.executable()
        } else {
            binaries.library()
        }
    }
    
    sourceSets {
        val jsMain by getting {
            if (isExtensionBuild) {
                kotlin.srcDir(preprocessedSrcDir)
                kotlin.srcDir(generatedSrcDir)
            }
            
            dependencies {
                implementation("tachiyomi.shim:tachiyomi-shim")
                implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.3")
                implementation("org.jetbrains.kotlinx:kotlinx-serialization-protobuf:1.7.3")
                implementation("com.fleeksoft.ksoup:ksoup:0.2.4")
            }
        }
    }
}

// =============================================================================
// Extension Build Tasks (config-cache compatible)
// =============================================================================

if (isExtensionBuild) {
    // Use abstract task classes from buildSrc for config-cache compatibility
    
    // Pre-compute paths that exist (for config cache compatibility)
    val multisrcDir = this@Build_gradle.multisrcPath
    val existingLibPaths = this@Build_gradle.libPaths.filter { it.exists() }.map { it.absolutePath }
    
    val preprocessSource = tasks.register<PreprocessSourceTask>("preprocessSource") {
        extensionLang.set(this@Build_gradle.extensionLang)
        extensionName.set(this@Build_gradle.extensionName)
        themePkg.set(this@Build_gradle.themePkg)
        this.libDeps.set(this@Build_gradle.libDeps)
        extensionSourcePath.set(this@Build_gradle.extensionSourcePath)
        if (multisrcDir?.exists() == true) {
            this.multisrcPath.set(multisrcDir)
        }
        this.libPaths.set(existingLibPaths)
        // Note: keiyoushi/utils comes from our shim (JS-compatible), not their core/ (JVM-only)
        jsImports.set(this@Build_gradle.jsImports)
        outputDir.set(preprocessedSrcDir)
    }
    
    val generateMain = tasks.register<GenerateMainTask>("generateMain") {
        extensionLang.set(this@Build_gradle.extensionLang)
        extensionName.set(this@Build_gradle.extensionName)
        extClassName.set(this@Build_gradle.extClassName)
        mainKtTemplate.set(this@Build_gradle.mainKtTemplate)
        outputDir.set(generatedSrcDir)
    }
    
    tasks.named("compileKotlinJs") {
        dependsOn(generateMain)
        dependsOn(preprocessSource)
    }
    
    // Output directory (configurable via -PoutputDir)
    val outputDir = File(this@Build_gradle.extensionsOutputDir, "$extensionLang-$extensionName")
    
    // Find extension icon (from keiyoushi repo)
    val extensionResPath = File(this@Build_gradle.extensionsRoot, "src/$extensionLang/$extensionName/res")
    val iconDensities = listOf("xxhdpi", "hdpi", "xhdpi", "xxxhdpi", "mdpi")
    val iconFile = iconDensities.map { File(extensionResPath, "mipmap-$it/ic_launcher.png") }
        .firstOrNull { it.exists() }
    
    // Bun bundler task
    val esbuildBundle = tasks.register<EsbuildBundleTask>("esbuildBundle") {
        dependsOn("compileProductionExecutableKotlinJs")
        inputFile.set(layout.buildDirectory.file("compileSync/js/main/productionExecutable/kotlin/$extensionLang-$extensionName.js"))
        outputFile.set(File(outputDir, "extension.js"))
    }
    
    // Final build task
    tasks.register<DevBuildTask>("devBuild") {
        dependsOn(esbuildBundle)
        extensionLang.set(this@Build_gradle.extensionLang)
        extensionName.set(this@Build_gradle.extensionName)
        extName.set(this@Build_gradle.extName)
        extVersionCode.set(this@Build_gradle.extVersionCode)
        nsfw.set(this@Build_gradle.isNsfw)
        preprocessedDir.set(preprocessedSrcDir)
        if (iconFile?.exists() == true) {
            this.iconFile.set(iconFile)
        }
        this.outputDir.set(outputDir)
    }
}

// =============================================================================
// Utility Tasks
// =============================================================================

tasks.register("listExtensions") {
    group = "help"
    description = "List all extensions from manifest"
    
    doLast {
        val manifest = rootProject.file("extensions-manifest.json")
        if (!manifest.exists()) {
            println("No extensions in manifest. Run: bun dev/scan-extensions.ts")
            return@doLast
        }
        
        @Suppress("UNCHECKED_CAST")
        val extensions = JsonSlurper().parseText(manifest.readText()) as List<Map<String, Any?>>
        val byLang = extensions.groupBy { it["lang"] as String }
        var total = 0
        
        for ((lang, exts) in byLang.toSortedMap()) {
            println("\n$lang/ (${exts.size} extensions)")
            exts.sortedBy { it["name"] as String }.forEach { ext ->
                println("  ${ext["name"]}")
                total++
            }
        }
        println("\nTotal: $total extensions")
    }
}
